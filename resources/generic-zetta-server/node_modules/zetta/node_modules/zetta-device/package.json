{
  "name": "zetta-device",
  "version": "0.11.0",
  "description": "Device class for Zetta.",
  "main": "device.js",
  "dependencies": {
    "node-uuid": "~1.4.1",
    "zetta-streams": "^0.2.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha -R spec ./test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/zettajs/zetta-device.git"
  },
  "keywords": [
    "zetta",
    "device"
  ],
  "author": {
    "name": "Kevin Swiber",
    "email": "kswiber@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/zettajs/zetta-device/issues"
  },
  "homepage": "https://github.com/zettajs/zetta-device",
  "readme": "# Zetta Device Module\n\n## Install\n\n```bash\n$ npm install zetta-device --save\n```\n\n## Reference and Usage\n\n#### Class: Zetta.Device\n\nThis is a zetta device modeled in software. With zetta you can create state machines for all of your devices that conditionally allow functionality to be exposed based on the `state` property.\nYou should inherit from this class and implement the init function `require('zetta-device');` or `require('zetta').Device;`.\n\n```js\nvar util = require('util');\nvar Device = require('zetta-device');\n\nfunction MyDevice(){\n  Device.call(this);\n}\nutil.inherits(MyDevice, Device);\n```\n\n##### Property: Device#state\n\nThis is the current state of your device modeled in software.\n\n##### Method: Device#init(config)\n\n* `config` DeviceConfig\n\nThis method should be implemented by you. The argument `config` is a configuration object that will allow you to setup your state machine, name your object, and give it a type.\n\n```js\nMyDevice.prototype.init = function(config) {\n  config\n    .type('device')\n    .state('on')\n    .name('CoolDevice')\n};\n\n```\n\n##### Method: Device#available(transition)\n\n* `transition` String\n\nCheck if a transition is available for use on the current device.\n\n```js\nif(device.available('turn-on')) {\n  //turn-on transition available\n}\n```\n\n##### Method: Device#call(name, [arguments...], callback)\n\n* `name` String\n* `arguments` Arguments for the transition.\n* `callback` Function\n\nThis method will call a transition on your state machine. You supply a splat fo additional arguments if required by the implementation of the particular transition. An optional callback can be provided as well. Callback is called once the state transition is complete.\n\n```js\ndevice.call('change-color', '#FF0000', function(err){\n  if(err) {\n    console.log('Color change error');\n  }\n});\n```\n\n##### Method: Device#save\n\nSave the device in it's current state to the zetta device registry.\n\n```js\ndevice.save();\n```\n\n##### Method: Device#createReadStream(name)\n\n* `name` String\n\nCreate an instance of a readable stream of values from the `name` of the stream.\n\n```js\nvar volumeStream = microphone.createReadStream('volume');\n```\n\n\n\n##### Method: DeviceConfig#when(state, options)\n\n* `state` String\n*  `options` Object\n\nThe `when` method on device config allows you to set what transitions are available in a particular state. The first argument of state should be a valid\nstate for the object, and the second takes an options object with a property called `allow` where you can define the available transitions for the state.\n\n```js\nMyDevice.prototype.init = function(config) {\n  config\n    .when('on', {allow: ['off']})\n};\n```\n\nThis method will conditionally set available transitions for your state machine based on the `state` property.\n\n##### Method: DeviceConfig#map(transition, func, [options])\n\n* `transition` String\n* `func` Function\n* `options` Array of Object\n\nThis method allows you to map transitions to functions. Whenever a transition is called on a state machine the corresponding function will be executed. The\n`options` array is where inputs to the transition are defined.\n\n```js\nMyDevice.prototype.init = function(config) {\n  config\n    .map('on', this.turnOn);\n    .map('strobe', this.strobe, [{name:'amount', type:'number'}])\n};\n\nMyDevice.prototype.turnOn = function(cb) {\n\n};\n\nMyDevice.prototype.strobe = function(amount, cb ){\n\n};\n```\n\n##### Method: DeviceConfig#stream(name, func, [options])\n\n* `name` String\n* `func` Function\n* `options` Object\n\n`stream` will allow for setting up streaming data out of zetta. The first argument `name` is to identify the stream, the second argument `func` is a callback function\nthat is executed to provide a user with a stream. The third argument `options` will allow a user to define the type of stream to be created `object` or `binary`\n\n```js\nMyDevice.prototype.init = function(config) {\n  config\n    .stream('value', this.streamValue);\n};\n\nMyDevice.prototype.streamValue = function(stream) {\n  setInterval(function(){\n    stream.write(Math.random());\n  }, 3000);\n}\n```\n\n\n##### Method: DeviceConfig#monitor(name)\n\n* `name` String\n\nStream a property from your device instance out of zetta. Zetta will monitor the property for changes, and if they occur will publish an event down the stream.\n\n```js\nfunction MyDevice() {\n  this.blah = 0;\n}\n\nMyDevice.prototype.init = function(config) {\n  config\n    .monitor('blah');\n}\n```\n",
  "readmeFilename": "README.md",
  "_id": "zetta-device@0.11.0",
  "_from": "zetta-device@^0.11.0"
}
